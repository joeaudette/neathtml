<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
<title>Fighting Cross Site Scripting (XSS) with Some Javascript Judo</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta http-equiv="content-style-type" content="text/css">
<meta http-equiv="expires" content="0">
<script type="text/javascript" src="neathtml.js?50</script>"></script>
<style>
.Untrusted {
	counter-increment: untrusted-num;
}

.Untrusted:after {
	content: " #" counter(untrusted-num);
}
</style>
</head>
<body>
	<h1>Fighting Cross Site Scripting (XSS) with Some Javascript Judo</h1>
	<p><em>by <a href="http://www.brettle.com/">Dean Brettle<a> (Last updated 8/31/2007 2:17 AM PDT)</em></p>
	<div>
	<h2>Overview</h2>
	<p>This page <a href="#Details">describes</a> and <a href="#Example">demonstrates</a> a technique for
	displaying untrusted content (e.g. a blog comment containing
	HTML markup):
	</p>
	<ul>
	<li>Safely - it uses a <em>whitelist</em> approach as a defense against current <em>and future</em> XSS attacks.</li>
	<li>Efficiently - the server only needs to do a handful of string replacements.  The bulk of the work is done using javascript
	on the client.  I call this "javascript judo" because it uses the source of an attacker's power (i.e. javascript) against him.  
	This approach was inspired by <a href="http://www.mindedsecurity.com/">Stefano Di Paola's</a> work on 
	<a href="http://www.wisec.it/sectou.php?id=46c5843ea4900">Preventing XSS with Data Binding</a>.</li>
	<li>Accessibly - with few exceptions, users without javascript (and search engine spiders) see untrusted content 
	normally.  In addition, non-javascript techniques are used to prevent untrusted content from invading
	trusted content in ways that could confuse the user.</li>
	</ul>
	<h3 id="Compatibility">Compatibility</h3>
	<p>
	The current implementation should work with any browser that supports javascript 1.3 or later.  It does <i>not</i>
	use the browser's internal XML/HTML parser to parse the untrusted content, thereby eliminating many
	browser compatibility issues.  It has been tested against:
	</p>
	<ul>
	<li>Microsoft Internet Explorer (IE) version 7</li>
	<li>Microsoft Internet Explorer (IE) version 6, except that when javascript is disabled the untrusted content
	is displayed in a fixed size div (with scroll bars if necessary).  This is necessary to prevent
	absolutely positioned untrusted content from displaying outside the box.</li>
	<li>Mozilla Firefox (FF) versions 1.5 and 2.0</li>
	<li>Opera 9</li>
	<li>Netscape 7.2, except that when javascript is disabled the untrusted content
	is displayed in a fixed size div with no scroll bars.</li>
	<li>Mac Safari versions 1.2, 1.3, and 2.0.</li>
	<li>Windows Safari version 3.0.2.</li>
	<li>Konqueror 3.5.7.</li>
	</ul>
	<h3 id="Limitations">Known Limitations</h3>
	<p>
	Other than the <a href="#Compatibility">browser compatibility</a> exceptions mentioned above, the following are
	the only known limitations at	the time of this writing:
	</p>
	<ul>
	<li>When javascript is disabled, tables that aren't at the top-level of the untrusted content (e.g. tables nested
	in tables, or tables in divs) will generally display as top-level tables.  The only way to
	safely support such tables for <em>non</em>-javascript users is to parse the
	untrusted content on the server.  The server overhead associated with such parsing might be acceptable 
	if it is only done when the untrusted content contains tables.</li>
	<li>When javascript is disabled, the untrusted content can increment any CSS counters on the page and thereby
	affect the values of those counters at subsequent places in the document.  For an example, see the end of the first 
	piece of untrusted content below.  The only way to avoid this is parse the untrusted content on the server.</li>
	</ul>	
	<p><em>Please send bugs, comments, and questions to dean at brettle dot com</em>.
	</p>
	</div>
	<h2 id="Details">Technical Details</h2>
	<p>If you don't want the gory details, you can <a href="#Example">skip to the examples</a> to see what it can do.
	Otherwise, here's how it works:</p>
	<ol>
	<li>Enclose the untrusted content in a &lt;table&gt; cell.  Now the only way for the untrusted content to
	get it's content out of the table (or trusted content into its table) is by closing the table (or starting a 
	new one).  To prevent that the server could just delete all table start and end tags from the untrusted content.
	Of course, then legitimate tables can't be used in untrusted content at all.  In many applications, that is
	acceptable.  In applications where tables are needed, a <a href="#Limitations">limited</a> solution is to 
	do the following replacements:<br />
	<table border="1">
	<tr><th>Regular Expression</th><th>Replacement</th></tr>
	<tr><td>&lt;table</td><td>&lt;NeatHtmlParserReset single='' double=&quot;&quot;&gt;&lt;/NeatHtmlParserReset&gt;&lt;/td>&lt;/tr>&lt;/table>&lt;table</td></tr>
	<tr><td>&lt;/table</td><td>&lt;NeatHtmlParserReset single='' double=&quot;&quot;&gt;&lt;/table&gt;&lt;table&gt;&lt;tr&gt;&lt;td</td></tr>
	</table>
	<br />
	The NeatHtmlParserReset tag is designed to reset the browser's HTML parser to a sane
	state, so that an attacker can't trick the browser into skipping table tags by doing something like 
	"&lt;tag &lt;table" or "&lt;tag attr='&lt;table".  It also serves as a marker that some javascript can
	later use to indentify these replacements and undo them.</li>
	<li>Put a div around the table, and style it to ensure that the content in the table can't use styles to display 
	something "outside the box".  These first 2 steps are sufficient to protect non-javascript users.</li>
	<li>Use document.write() to inject some special markup just before the untrusted content.  The injected markup
	is chosen to cause the browser's
	parser to not treat subsequent text as markup.  For most browsers, inject "&lt;!&#45;&#45;" to start a comment. 
	On browsers where the DOM doesn't provide access to the contents of
	comments (e.g. Safari and Konqueror), inject "&lt;xmp&gt;"	instead (which for historical reasons stops 
	processing normal markup).</li>
	<li>Put the close tags that correspond to our injected markup after the untrusted content.  To prevent the 
	untrusted content from escaping the javascript-injected jail, the server needs to replace "&#45;&#45;" with
	"&amp;#45;&amp;#45;", "&lt;xmp" with "&amp;lt;xmp", and "&lt;/xmp" with "&amp;lt;/xmp".  The server should also remove any HTML comments before
	doing those replacements.
	They aren't a security threat, but they will corrupt the display of the 
	untrusted content.  If the app that doesn't expect benign content to contain comments, it does not need
	to strip	comments because only malicious content will be corrupted.</li>
	<li>Use javascript and the DOM to extract the untrusted content, filter it, and replace our javscript-injected
	jail with the result.  The filter converts the untrusted "tag soup" content into safe well-formed HTML.
	It can be configured to allow, prohibit, or modify, any element, attribute, or style.  The default
	configuration is designed to prohibit Cross Site Scripting (XSS) attacks and other similar attacks.  
	To ensure that "tag soup" is displayed properly and to maximize cross-browser compatibility, the filter uses a 
	regex based parser instead of using the XML parser available in many browsers.</li>
	</ol>
	</p>
	
	<h3>String Replacements</h3>
	<p id="Replacements">
	Below is a full list of the string replacements that the server needs to do.
	</p>
	<p>NOTE: All replacements must be
	<b>case-insensitive</b> and <b>global</b>.  Also be sure to <b>escape your quotes and slashes</b> as 
	appropriate for your environment.
	</p>
	<table border="1">
	<tr><th>Regular Expression</th><th>Replacement</th><th>Notes</th></tr>
	<tr><td>&lt;table</td><td>&lt;NeatHtmlParserReset&nbsp;single=''&nbsp;double=&quot;&quot;&gt;&lt;/NeatHtmlParserReset&gt;&lt;/td>&lt;/tr>&lt;/table>&lt;table</td>
		<td rowspan="2">Prevents intermingling of untrusted and trusted markup.</td></tr>
	<tr><td>&lt;/table</td><td>&lt;NeatHtmlParserReset&nbsp;single=''&nbsp;double=&quot;&quot;&gt;&lt;/table&gt;&lt;table&gt;&lt;tr&gt;&lt;td</td></tr>
	<tr><td>&lt;!--([^-]*-)+-[^&gt;]*&gt;</td><td></td>
		<td>Optional HTML comment stripping.  Does not affect security.  Only affects usability if benign content is expected to contain HTML comments.</td></tr>
	<tr><td>&#45;&#45;</td><td>&amp;#45;&amp;#45;</td>
		<td>Prevents escape from jail injected by javascript on most browsers.  If stripping comments, strip them before doing this replacement.</td></tr>
	<tr><td>&lt;/xmp</td><td>&amp;lt;/xmp</td>
		<td rowspan="2">Prevents escape from jail injected by javascript on browsers that don't provide DOM access to 
		comments (e.g. Safari and Konqueror).</td></tr>
	<tr><td>&lt;xmp</td><td>&amp;lt;xmp</td></tr>
	</table>
	<p>In many programming environments it is possible to specify a function to be called for each regular expression
	match, and the function is passed information about which parts of the regular expression matched.  In such an
	environment, you can combine the above regular expressions so that the untrusted content only needs to be scanned
	once on the server. 
	</p>
	<h2 id="Example">Examples</h2>
	<p>The examples below illustrate the results of the approach.  To try your own examples, save this page and 
	the neathtml.js file and look at the HTML source.  Find the the untrusted
	content and try replacing it with something that will execute script.  The only rules are that you 
	need to do the <a href="#Replacements">required string replacements</a> that the server would normally do to 
	the untrusted content.
	</p>
	<h3>Trusted Content</h3>
	<p>
	This is trusted content.
	Here is <a id="trustedLinkBefore" href="#">a link</a> that some trusted script will attach an onclick handler to.
	Clicking the link should bring up an alert.  If it doesn't or a link in untrusted content does, then there is a
	hole.  The script finds the link using document.getElementById("trustedLink"), 
	so untrusted content needs to be prevented from	containing elements with such an ID.
	</p>
	<h3 class="Untrusted">Untrusted Content</h3>
	<p>The following content is untrusted:</p>
	<!-- Note: In most browsers, the style="overflow: hidden; position: relative" on the div below prevents 
	well-formed but untrusted content from getting outside the box when javascript is disabled.  In IE6 and
	earlier a width and height needs to be specified. -->
	<![if gte IE 7]>
	<div style="overflow: hidden; position: relative; border: solid 1px;">
	<![endif]>
	<!--[if lt IE 7]>
	<div style="overflow: auto; position: relative; border: solid 1px; width: 100%; height: 400px;">	
	<![endif]-->
	<!-- Note: the table forces all following content (up to </table>) to be inside the table node.  This means
	the server doesn't have to check for well-formedness.  It can just HTML-encode all '<table>', and '</table>'.
	Of course that means tables would not work in the untrusted content. To get the best of both worlds, only
	check for well-formedness if the untrusted content contains "</table>".  -->
	<table><tr><td>
		<!-- test comment --><script type="text/javascript">
		// <![CDATA[
		NeatHtml.DefaultFilter.BeginUntrusted();
		// ]]>
		</script><div><?xml-stylesheet href="xss.css" type="text/css" ?>
			<p>Here is a script element...</p>
			<script type="text/javascript">
			window.alert("XSS from script element");
			</script>
			<p>Here is a normal link:
			<a href="http://www.google.com/">normal link to google</a>
			</p>
			<p>Here is the same link with an onclick handler added:
			<a onclick="window.alert('XSS on click')" href="http://www.google.com/">onclick link</a>
			</p>
			<p>Here is a link that uses the javascript protocol:
			<a href="javascript:alert('XSS on link')">javascript link</a>
			</p>
			<p>Here are some links which try to spoof trusted element IDs (i.e. IDs that trusted script later uses to
			find elements and attach handlers):
			a
			<a id="trustedLinkBefore" href="http://www.google.com/">link with an ID that already exists</a> 
			and a
			<a id="trustedLinkAfter" href="http://www.google.com/">link with an ID that will be used later</a>
			</p>
			<p>Here is a CDATA section containing a script element:
			<![CDATA[
			<script type="text/javascript">
			window.alert("XSS from script element in CDATA section");
			</script>
			]]>
			</p>
			<p style="background-color: rgb(192,255,192); nonstandard-attribute1: expression(alert('XSS from style')); nonstandard-attribute2: expr/**/ession(alert('XSS from style with comment')); nonstandard-attribute3: expres\000073ion(alert('XSS from style with escape'));">
			Here is a paragraph with javascript expressions in the inline style (IE only).  It should have a green
			background to show safe styles are still applied even when unsafe styles are present.
			
			</p>
			<p class="XSS">
			Here is a paragraph that uses a class defined in an external stylesheet 
			(referenced by an &lt;?xml-stylesheet?&gt; processing instruction) 
			that contains javascript expressions.  The stylesheet should not be used, so this paragraph should not be
			red and no scripts should run.
			</p>
			<p>Here we try to display "Let me out!" outside of the box using absolute positioning:</p>
			<div style="position: absolute; top: 0; right: 0; color: red;">Let me out!</div>
			<div style="position: absolute; top: -100px; right: 0; color: red;">Let me out with a negative top property!</div>
			
			<p style="counter-increment: untrusted-num;">Here we try to increment the CSS counter used for the 
			"Untrusted Content #x" headings.  If the "attack" succeeds, the next section heading will say "Untrusted Content #3"
			instead of "Untrusted Content #2".  This can only be prevented
			if javascript is enabled.  If the heading just says "Untrusted Content", that just means your browser doesn't support
			the CSS that would be needed for the attack to succeed.</p>
			
			<p>This paragraph has some <font face="&#0;
			">non-printable</font> and <font face="&#xdead;">non-ascii</font> characters in attribute values.  
			We just want to be sure that they don't mess up the parsing.</p>
		</div><xmp></xmp>
		<!-- ' " > -->
		<!-- The preceding comment ensures that the comment and any attrs and tags started
		by the untrusted content have been closed. -->
	</td></tr></table></div>
	<script type="text/javascript">
	// <![CDATA[
	NeatHtml.DefaultFilter.ProcessUntrusted();
	// ]]>
	</script>

<h3 class="Untrusted">Untrusted Content</h3>
    <p>The next bit of content shows how we handle tag soup (specifically HTML3.2 that is not valid XML) and attempts
    to close the containing &lt;div&gt; element to display content
    outside	the box.  If you don't have javascript enabled, the untrusted content will remain in the box 
    (because an inner table would need to be closed first).  Exactly what is displayed in the box will depend on the 
    how your browser's tag soup parser works.  If you have javascript enabled, we just javascript to convert the
    tag soup to XML before letting the browser parse the XML.  The conversion should work pretty well, but if the
    result isn't valid XML, the worst that will happen is an error message will be displayed in the box.</p>
	<div style="overflow: hidden; position: relative; border: solid 1px; padding: 0;">
	<table><tr><td>
		<!-- test comment --><script type="text/javascript">
		// <![CDATA[
		NeatHtml.DefaultFilter.BeginUntrusted();
		// ]]>
		</script><div>

			<p><em>Start of untrusted content...</em></p>
			
			<p>This paragraph doesn't have an end tag.
			
			<p>Here is a <br> line break with "&lt;br&gt;" instead of "&lt;br /&gt;".
			
			<p>Here is a list where the list items don't have end tags:
			<ul>
				<li>item #1
				<li>item #2
			</ul>
			
			<p>Here is a table with lots of missing end tags:
			<NeatHtmlParserReset single='' double=""></NeatHtmlParserReset></td></tr></table><table border=1>
				<tr><td>0,0<td>0,1<td>0,2
				<tr><td>1,0<td>1,1<td>1,2
				<tr><td>2,0<td>2,1<td>2,2
			<NeatHtmlParserReset single='' double=""></table><table><tr><td>
			
			<p>Below is a 3x3 table nested in the middle cell of another 3x3 table.  If javascript is disabled,
			this will display as 3 separate
			tables (the outer table will be split into 2 pieces).  
			This behavior is a <a href="#Limitations">known limitation</a>.
			<NeatHtmlParserReset single='' double=""></NeatHtmlParserReset></td></tr></table><table border=1>
				<tr><td>0,0</td><td>0,1</td><td>0,2</td></tr>
				<tr><td>1,0</td><td><NeatHtmlParserReset single='' double=""></NeatHtmlParserReset></td></tr></table><table border=1>
				<tr><td>A,A</td><td>A,B</td><td>A,C</td></tr>
				<tr><td>B,A</td><td>B,B</td><td>B,C</td></tr>
				<tr><td>C,A</td><td>C,B</td><td>C,C</td></tr>
			<NeatHtmlParserReset single='' double=""></table><table><tr><td></td><td>1,2</td></tr>
				<tr><td>2,0</td><td>2,1</td><td>2,2</td></tr>
			<NeatHtmlParserReset single='' double=""></table><table><tr><td>

			<p>Here we close an element that isn't open</em>.  
			The extra end tag will be removed during conversion to XML.
			
			<p>Here is a link with an unquoted attribute value with unencoded ampersands
			and an attribute with an implicit value:
			<a implicit_attr href=http://www.google.com/search?hl=en&q=neathtml&btnG=Search>Google</a>
			
			<p>Here is some text <B>formatted</B> <i>with</I> <U>tags</u> with varying cases.
			
			<p>Here is an '<' and an '&' that haven't been encoded.
			
			<p>Here are a few character entities: &#65;, &#x41;, &#X41;, "&nbsp;"
						
			<p>OK.  Enough soup, let's see if we can break out of the box...</p>
            </div>
            </div>
            </div>
			<p>Help! Let me out of this box!</p>
			<p><em>End of untrusted content...</em></p>
									
		</div><xmp></xmp>
		<!-- ' " > -->
		<!-- The preceding comment might not be necessary but it should ensure that any attributes and tags started
		by the untrusted content have been closed. -->
	</td></tr></table></div>
	<script type="text/javascript">
	// <![CDATA[
	NeatHtml.DefaultFilter.ProcessUntrusted();
	// ]]>
	</script>

	<h3>Trusted Content</h3>
	<p>
	This is trusted content again.
	Here is <a id="trustedLinkAfter" href="#">another link</a> that some trusted script will attach an onclick handler to
	based on it's ID.
	</p>  
	<script type="text/javascript">
	<!--
	window.onload = function() 
	{
		document.getElementById("trustedLinkBefore").onclick 
			= function () { 
				window.alert("You should only see this when clicking the link in the\n trusted content that appear before the untrusted content."); 
				return false;
			};
		document.getElementById("trustedLinkAfter").onclick 
			= function () { 
				window.alert("You should only see this when clicking the link in the\n trusted content that appear after the untrusted content."); 
				return false;
			};
	}
	// -->
	</script>
</body>
</html>