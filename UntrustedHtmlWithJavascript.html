<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
<title>Untrusted HTML With Javascript</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta http-equiv="content-style-type" content="text/css">
<meta http-equiv="expires" content="0">
<script type="text/javascript" src="neathtml.js?50</script>"></script>
<style>
.Untrusted {
	counter-increment: untrusted-num;
}

.Untrusted:after {
	content: " #" counter(untrusted-num);
}
</style>
</head>
<body>
	<h1>Restricting Untrusted HTML With Javascript</h1>
	<p><em>Last updated 8/28/2007 12:55 PM PDT</em></p>
	<div>
	<p>
	This is inspired by <a href="http://www.mindedsecurity.com/">Stefano Di Paola's</a> work on 
	<a href="http://www.wisec.it/sectou.php?id=46c5843ea4900">Preventing XSS with Data Binding</a>.
	My primary contributions are lots of browser compatibility work and the idea to use
	document.write() to inject some markup that will cause the parser to stop processing normal tags.  We inject this
	immediately before the untrusted content.  Then we later
	use javascript to extract the untrusted content, parse it as XML (using the browser's parser), 
	clean the resulting DOM, and put the result where the injected markup was.
	For most browsers we inject "&lt;!&#45;&#45;" to start a comment. On browsers where we can't access the contents of
	comments (e.g. Safari and Konqueror), we inject &lt;xmp&gt;	instead (which for historical reasons stops 
	processing normal markup.  In either case, the key is that if javascript
	is not available (e.g. search engines spiders), nothing is injected and the content displays normally.
	</p>
	<p>
	To play with this, save this page and look at the HTML source.  Find the &lt;div&gt;s containing the untrusted
	content and try replacing their contents with something that will execute script.  The only rules are that you 
	need to do the following things that the server would normally do to the untrusted content:
	</p>
	<ul>
	<li>Remove any comments.  They aren't a security threat, but they will corrupt the display of the 
	untrusted content.  In other words, an app that doesn't expect benign content to contain comments would not need
	to strip	comments.</li>
	<li>Replace '&#45;&#45;' with '&amp;#45;&amp;#45;'.  That string is a threat because it would end the enclosing 
	javascript-generated	comment.</li>
	<li>Replace '&lt;/xmp' with '&amp;lt;/xmp'.  That string is a threat because it would end the enclosing 
	javascript-generated	&lt;xmp&gt; element needed by browsers like Safari and Konqueror.</li>
	<li>If the content contains '&lt;table' or '&lt;/table', either check the content for well-formedness, or 
	if you are willing to disallow tables in the untrusted content, just replace '&lt;table' with 
	'&amp;lt;table' and '&lt;/table' with '&amp;lt;/table'.
	This is necessary because we put the untrusted content in a &lt;table&gt; to prevent parser based attacks on users
	that don't have javascript.  This works because tag soup parsing seems to ignore end tags for
	outer elements until it sees the table end tag.</li>
	</ul>
	<p>
	The current implementation seems to work with:
	</p>
	<ul>
	<li>Microsoft Internet Explorer (IE) version 7</li>
	<li>Microsoft Internet Explorer (IE) version 6, except that when javascript is disabled the untrusted content
	is displayed in a fixed size div (with scroll bars if necessary).  This is necessary to prevent
	absolutely positioned untrusted content from displaying outside the box.</li>
	<li>Mozilla Firefox (FF) versions 1.5 and 2.0</li>
	<li>Opera 9</li>
	<li>Netscape 7.2, except that when javascript is disabled the untrusted content
	is displayed in a fixed size div with no scroll bars.</li>
	<li>Mac Safari versions 1.2, 1.3, and 2.0.</li>
	<li>Windows Safari version 3.0.2.</li>
	<li>Konqueror 3.5.7.</li>
	</ul>
	<p>
	Known limitations:
	<ul>
	<li>When javascript is disabled, the untrusted content can increment any CSS counters you have and thereby affect
	the values of those counters at subsequent places in the document.  For an example, see the end of the first 
	piece of untrutsed content below.</li>
	</ul>	
	</p>
	<p>Please report bugs and send comments to dean at brettle dot com.
	</p>
	</div>
	<h2>Example</h2>
	<h3>Trusted Content</h3>
	<p>
	This is trusted content.
	Here is <a id="trustedLinkBefore" href="#">a link</a> that some trusted script will attach an onclick handler to.
	Clicking the link should bring up an alert.  If it doesn't or a link in untrusted content does, then there is a
	hole.  The script finds the link using document.getElementById("trustedLink"), 
	so untrusted content needs to be prevented from	containing elements with such an ID.
	</p>
	<h3 class="Untrusted">Untrusted Content</h3>
	<p>The following content is untrusted:</p>
	<!-- Note: In most browsers, the style="overflow: hidden; position: relative" on the div below prevents 
	well-formed but untrusted content from getting outside the box when javascript is disabled.  In IE6 and
	earlier a width and height needs to be specified. -->
	<![if gte IE 7]>
	<div style="overflow: hidden; position: relative; border: solid 1px;">
	<![endif]>
	<!--[if lt IE 7]>
	<div style="overflow: auto; position: relative; border: solid 1px; width: 100%; height: 400px;">	
	<![endif]-->
	<!-- Note: the table forces all following content (up to </table>) to be inside the table node.  This means
	the server doesn't have to check for well-formedness.  It can just HTML-encode all '<table>', and '</table>'.
	Of course that means tables would not work in the untrusted content. To get the best of both worlds, only
	check for well-formedness if the untrusted content contains "</table>".  -->
	<table><tr><td>
		<!-- test comment --><script type="text/javascript">
		// <![CDATA[
		NeatHtml.DefaultFilter.BeginUntrusted();
		// ]]>
		</script><div><?xml-stylesheet href="xss.css" type="text/css" ?>
			<p>Here is a script element...</p>
			<script type="text/javascript">
			window.alert("XSS from script element");
			</script>
			<p>Here is a normal link:
			<a href="http://www.google.com/">normal link to google</a>
			</p>
			<p>Here is the same link with an onclick handler added:
			<a onclick="window.alert('XSS on click')" href="http://www.google.com/">onclick link</a>
			</p>
			<p>Here is a link that uses the javascript protocol:
			<a href="javascript:alert('XSS on link')">javascript link</a>
			</p>
			<p>Here are some links which try to spoof trusted element IDs (i.e. IDs that trusted script later uses to
			find elements and attach handlers):
			a
			<a id="trustedLinkBefore" href="http://www.google.com/">link with an ID that already exists</a> 
			and a
			<a id="trustedLinkAfter" href="http://www.google.com/">link with an ID that will be used later</a>
			</p>
			<p>Here is a CDATA section containing a script element:
			<![CDATA[
			<script type="text/javascript">
			window.alert("XSS from script element in CDATA section");
			</script>
			]]>
			</p>
			<p style="background-color: rgb(192,255,192); nonstandard-attribute1: expression(alert('XSS from style')); nonstandard-attribute2: expr/**/ession(alert('XSS from style with comment')); nonstandard-attribute3: expres\000073ion(alert('XSS from style with escape'));">
			Here is a paragraph with javascript expressions in the inline style (IE only).  It should have a green
			background to show safe styles are still applied even when unsafe styles are present.
			
			</p>
			<p class="XSS">
			Here is a paragraph that uses a class defined in an external stylesheet 
			(referenced by an &lt;?xml-stylesheet?&gt; processing instruction) 
			that contains javascript expressions.  The stylesheet should not be used, so this paragraph should not be
			red and no scripts should run.
			</p>
			<p>Here we try to display "Let me out!" outside of the box using absolute positioning:</p>
			<div style="position: absolute; top: 0; right: 0; color: red;">Let me out!</div>
			<div style="position: absolute; top: -100px; right: 0; color: red;">Let me out with a negative top property!</div>
			
			<p style="counter-increment: untrusted-num;">Here we try to increment the CSS counter used for the 
			"Untrusted Content #x" headings.  If the "attack" succeeds, the next section heading will say "Untrusted Content #3"
			instead of "Untrusted Content #2".  This can only be prevented
			if javascript is enabled.</p>
		</div><xmp></xmp>
		<!-- ' " > -->
		<!-- The preceding comment ensures that the comment and any attrs and tags started
		by the untrusted content have been closed. -->
	</td></tr></table></div>
	<script type="text/javascript">
	// <![CDATA[
	NeatHtml.DefaultFilter.ProcessUntrusted();
	// ]]>
	</script>

<h3 class="Untrusted">Untrusted Content</h3>
    <p>The next bit of content shows how we handle tag soup (specifically HTML3.2 that is not valid XML) and attempts
    to close the containing &lt;div&gt; element to display content
    outside	the box.  If you don't have javascript enabled, the untrusted content will remain in the box 
    (because an inner table would need to be closed first).  Exactly what is displayed in the box will depend on the 
    how your browser's tag soup parser works.  If you have javascript enabled, we just javascript to convert the
    tag soup to XML before letting the browser parse the XML.  The conversion should work pretty well, but if the
    result isn't valid XML, the worst that will happen is an error message will be displayed in the box.</p>
	<div style="overflow: hidden; position: relative; border: solid 1px; padding: 0;">
	<table><tr><td>
		<!-- test comment --><script type="text/javascript">
		// <![CDATA[
		NeatHtml.DefaultFilter.BeginUntrusted();
		// ]]>
		</script><div>
		
			<p><em>Start of untrusted content...</em></p>
			
			<p>This paragraph doesn't have an end tag.
			
			<p>Here is a <br> line break with "&lt;br&gt;" instead of "&lt;br /&gt;".
			
			<p>Here is a list where the list items don't have end tags:
			<ul>
				<li>item #1
				<li>item #2
			</ul>
			
			<p>Here is a table with lots of missing end tags:
			<table border=1>
				<tr><td>0,0<td>0,1<td>0,2
				<tr><td>1,0<td>1,1<td>1,2
				<tr><td>2,0<td>2,1<td>2,2
			</table>
			
			<p>Here we close an element that isn't open</em>.  
			The extra end tag will be removed during conversion to XML.
			
			<p>Here is a link with an unquoted attribute value with unencoded ampersands
			and an attribute with an implicit value:
			<a implicit_attr href=http://www.google.com/search?hl=en&q=neathtml&btnG=Search>Google</a>
			
			<p>Here is some text <B>formatted</B> <i>with</I> <U>tags</u> with varying cases.
			
			<p>Here is an '<' and an '&' that haven't been encoded.
			
			<p>Here are a few character entities: &#65;, &#x41;, &#X41;, "&nbsp;"
						
			<p>OK.  Enough soup, let's see if we can break out of the box...</p>
            </div>
            </div>
            </div>
			<p>Help! Let me out of this box!</p>
			<p><em>End of untrusted content...</em></p>
									
		</div><xmp></xmp>
		<!-- ' " > -->
		<!-- The preceding comment might not be necessary but it should ensure that any attributes and tags started
		by the untrusted content have been closed. -->
	</td></tr></table></div>
	<script type="text/javascript">
	// <![CDATA[
	NeatHtml.DefaultFilter.ProcessUntrusted();
	// ]]>
	</script>

	<h3>Trusted Content</h3>
	<p>
	This is trusted content again.
	Here is <a id="trustedLinkAfter" href="#">another link</a> that some trusted script will attach an onclick handler to
	based on it's ID.
	</p>  
	<script type="text/javascript">
	<!--
	window.onload = function() 
	{
		document.getElementById("trustedLinkBefore").onclick 
			= function () { 
				window.alert("You should only see this when clicking the link in the\n trusted content that appear before the untrusted content."); 
				return false;
			};
		document.getElementById("trustedLinkAfter").onclick 
			= function () { 
				window.alert("You should only see this when clicking the link in the\n trusted content that appear after the untrusted content."); 
				return false;
			};
	}
	// -->
	</script>
</body>
</html>